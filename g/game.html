<!doctype html>
<html>
<head>
  <link rel="stylesheet" href="css/game.css">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1, minimum-scale=1, user-scalable=0">
  <title>game name</title>
</head>
<body>
  <!-- 开始 -->
  <section id="p1">
    <div class="btn-start " id="btnStart">开始游戏</div>
  </section>
  <!-- 游戏页面 -->
  <section id="p2">
    <div class="info">
      <span class="score">得分 <i> 0</i></span>
    </div>
    <p style="color:#fff">点到彩色方块+1分，点到黑色方块游戏结束</p>
    <div class="square">
      <span class="box"></span>
      <span class="box"></span>
      <span class="box"></span>
      <span class="box"></span>
      <span class="box"></span>
      <span class="box"></span>
      <span class="box"></span>
      <span class="box"></span>
      <span class="box"></span>
    </div>
  </section>
  <!-- 分享页面 -->
  <section id="p3">
    <span style="color:#fff;">游戏结束</span>
  </section>
  <script src="http://cdn.bootcss.com/zepto/1.1.4/zepto.min.js"></script>
  <script>
  // zepto touch.js
  ;(function($){
    var touch = {},
      touchTimeout, tapTimeout, swipeTimeout, longTapTimeout,
      longTapDelay = 750,
      gesture

    function swipeDirection(x1, x2, y1, y2) {
      return Math.abs(x1 - x2) >=
        Math.abs(y1 - y2) ? (x1 - x2 > 0 ? 'Left' : 'Right') : (y1 - y2 > 0 ? 'Up' : 'Down')
    }

    function longTap() {
      longTapTimeout = null
      if (touch.last) {
        touch.el.trigger('longTap')
        touch = {}
      }
    }

    function cancelLongTap() {
      if (longTapTimeout) clearTimeout(longTapTimeout)
      longTapTimeout = null
    }

    function cancelAll() {
      if (touchTimeout) clearTimeout(touchTimeout)
      if (tapTimeout) clearTimeout(tapTimeout)
      if (swipeTimeout) clearTimeout(swipeTimeout)
      if (longTapTimeout) clearTimeout(longTapTimeout)
      touchTimeout = tapTimeout = swipeTimeout = longTapTimeout = null
      touch = {}
    }

    function isPrimaryTouch(event){
      return (event.pointerType == 'touch' ||
        event.pointerType == event.MSPOINTER_TYPE_TOUCH)
        && event.isPrimary
    }

    function isPointerEventType(e, type){
      return (e.type == 'pointer'+type ||
        e.type.toLowerCase() == 'mspointer'+type)
    }

    $(document).ready(function(){
      var now, delta, deltaX = 0, deltaY = 0, firstTouch, _isPointerType

      if ('MSGesture' in window) {
        gesture = new MSGesture()
        gesture.target = document.body
      }

      $(document)
        .bind('MSGestureEnd', function(e){
          var swipeDirectionFromVelocity =
            e.velocityX > 1 ? 'Right' : e.velocityX < -1 ? 'Left' : e.velocityY > 1 ? 'Down' : e.velocityY < -1 ? 'Up' : null;
          if (swipeDirectionFromVelocity) {
            touch.el.trigger('swipe')
            touch.el.trigger('swipe'+ swipeDirectionFromVelocity)
          }
        })
        .on('touchstart MSPointerDown pointerdown', function(e){
          if((_isPointerType = isPointerEventType(e, 'down')) &&
            !isPrimaryTouch(e)) return
          firstTouch = _isPointerType ? e : e.touches[0]
          if (e.touches && e.touches.length === 1 && touch.x2) {
            // Clear out touch movement data if we have it sticking around
            // This can occur if touchcancel doesn't fire due to preventDefault, etc.
            touch.x2 = undefined
            touch.y2 = undefined
          }
          now = Date.now()
          delta = now - (touch.last || now)
          touch.el = $('tagName' in firstTouch.target ?
            firstTouch.target : firstTouch.target.parentNode)
          touchTimeout && clearTimeout(touchTimeout)
          touch.x1 = firstTouch.pageX
          touch.y1 = firstTouch.pageY
          if (delta > 0 && delta <= 250) touch.isDoubleTap = true
          touch.last = now
          longTapTimeout = setTimeout(longTap, longTapDelay)
          // adds the current touch contact for IE gesture recognition
          if (gesture && _isPointerType) gesture.addPointer(e.pointerId);
        })
        .on('touchmove MSPointerMove pointermove', function(e){
          if((_isPointerType = isPointerEventType(e, 'move')) &&
            !isPrimaryTouch(e)) return
          firstTouch = _isPointerType ? e : e.touches[0]
          cancelLongTap()
          touch.x2 = firstTouch.pageX
          touch.y2 = firstTouch.pageY

          deltaX += Math.abs(touch.x1 - touch.x2)
          deltaY += Math.abs(touch.y1 - touch.y2)
        })
        .on('touchend MSPointerUp pointerup', function(e){
          if((_isPointerType = isPointerEventType(e, 'up')) &&
            !isPrimaryTouch(e)) return
          cancelLongTap()

          // swipe
          if ((touch.x2 && Math.abs(touch.x1 - touch.x2) > 30) ||
              (touch.y2 && Math.abs(touch.y1 - touch.y2) > 30))

            swipeTimeout = setTimeout(function() {
              touch.el.trigger('swipe')
              touch.el.trigger('swipe' + (swipeDirection(touch.x1, touch.x2, touch.y1, touch.y2)))
              touch = {}
            }, 0)

          // normal tap
          else if ('last' in touch)
            // don't fire tap when delta position changed by more than 30 pixels,
            // for instance when moving to a point and back to origin
            if (deltaX < 30 && deltaY < 30) {
              // delay by one tick so we can cancel the 'tap' event if 'scroll' fires
              // ('tap' fires before 'scroll')
              tapTimeout = setTimeout(function() {

                // trigger universal 'tap' with the option to cancelTouch()
                // (cancelTouch cancels processing of single vs double taps for faster 'tap' response)
                var event = $.Event('tap')
                event.cancelTouch = cancelAll
                touch.el.trigger(event)

                // trigger double tap immediately
                if (touch.isDoubleTap) {
                  if (touch.el) touch.el.trigger('doubleTap')
                  touch = {}
                }

                // trigger single tap after 250ms of inactivity
                else {
                  touchTimeout = setTimeout(function(){
                    touchTimeout = null
                    if (touch.el) touch.el.trigger('singleTap')
                    touch = {}
                  }, 250)
                }
              }, 0)
            } else {
              touch = {}
            }
            deltaX = deltaY = 0

        })
        // when the browser window loses focus,
        // for example when a modal dialog is shown,
        // cancel all ongoing events
        .on('touchcancel MSPointerCancel pointercancel', cancelAll)

      // scrolling the window indicates intention of the user
      // to scroll, not tap or swipe, so cancel all ongoing events
      $(window).on('scroll', cancelAll)
    })

    ;['swipe', 'swipeLeft', 'swipeRight', 'swipeUp', 'swipeDown',
      'doubleTap', 'tap', 'singleTap', 'longTap'].forEach(function(eventName){
      $.fn[eventName] = function(callback){ return this.on(eventName, callback) }
    })
  })(Zepto)
  </script>

  <!-- 页面脚本 -->
  <script>
    $(function(){

      initSquare();

      // var colors=['#000','#09f','#6ff','#900','#9fc','#c63','#f66','#fc0'];

      $('.btn-start').on('tap',function(){
        var $p1=$('#p1'),
            $p2=$('#p2');
        $p1.hide();
        $p2.show();

        Game.init();
        Game.start();
      })

      // $('.box').on('tap',function(){
      //   // var $box=$(this),
      //   //     colorIndex=Math.floor(Math.random()*8),
      //   //     color=colors[colorIndex];
      //   // $box.css('background-color',color);

      // })
    })

    // 设置方格宽度/高度
    function initSquare(){
      var $square=$('.square'),
          width=$(window).width()||300;
      $square.css({
        width:width + 'px',
        height:width + 'px'
      });
    }

    // 方格类
    var Box=function(){
      // 方格内妹子
      this.girl=null;
      // 方格元素
      this.boxElement={};
      // 点击事件
      this.onTap=function(){
        // if(this.girl.number===0){

        // }
        // else{
        //   return;
        // }
        //
        // 方格里没有妹子
        // debugger
        if(!this.girl) return 0;
        // 点中不好看的妹子
        else if(this.girl.number===0) return -1;
        // 点中的妹子还可以被点击
        else if(this.girl.isLive){
          this.girl.isLive=false;
          return 1;
        }
        // 妹子已经被点击过了
        else{
          return 0;
        }


        // 如果妹子还能被点击
        // if(this.girl.isLive){
        //   this.girl.isLive=false;
        //   return (this.girl.number===0);
        // }
      };
    }

    // 妹子类
    var Girl=function(photo){
      // 妹子的编号
      this.number=-1;
      // 妹子在第几个方格
      this.box=-1;
      // 妹子照片
      this.photo='';
      // 是否还可以再点击
      this.isLive=true;

      // this.init=function(photo){
      //   this.photo=photo;
      // }
      // this.init(photo);
      this.photo=photo;

      // 妹子出现
      this.active=function(){
        var girl=this,
            box=girl.box;
        box.boxElement.css('background-color',girl.photo);
        setTimeout(function(){
          girl.hide();
        },1000);
      }

      // 妹子隐藏
      this.hide=function(){
        // debugger
        this.isLive=true;
        this.box.boxElement.css('background-color','#7bc3fd');
        this.box.girl=null;
        this.onHide();
      }

      // 妹子隐藏扩展
      this.onHide=function(){};

      // 妹子被点击扩展
      // this.onClick=function(){};
    }

    // 游戏控制类
    var Game={
      time:30,
      boxes:[],
      girlPhoto:{
        0:'#000',
        1:'#09f',
        2:'#6ff',
        3:'#900',
        4:'#9fc',
        5:'#6f0',
        6:'#90c',
        7:'#99f',
        8:'#c36',
        9:'#ff6'
      },
      girls:[],
      activeBoxes:{},
      activeGirls:{},
      init:function(){
        var game=this;
        // game.boxes=$('.box');
        $('.box').each(function(i){
          var box=new Box();
          box.boxElement=$(this).on('tap',function(){
            // TODO：点中不好看的妹子，游戏结束
            var result=box.onTap();
            if(result<0){
              $('#p2').hide();
              $('#p3').show();
            }
            else{
              game.changeScore(result);
            }
          });

          game.boxes.push(box);
        })

        // 创建妹子
        for(var i=0;i<10;i++){
          var girl=new Girl(game.girlPhoto[i]);
          girl.number=i;
          girl.onHide=function(){
            // debugger
            // var boxIndex=game.boxes.index(this.box);
            var boxIndex=$.inArray(this.box,game.boxes);
            game.activeBoxes[boxIndex]=null;
            game.activeGirls[this.number]=null;
          }
          this.girls.push(girl);
        }
      },

      start:function(){
        var game=this,
            boxIndex=Math.floor(Math.random()*9),
            girlIndex=Math.floor(Math.random()*10),
            box,girl;

        while(game.activeBoxes[boxIndex]){
          boxIndex=Math.floor(Math.random()*9);
        }
        box=game.boxes[boxIndex];

        while(game.activeGirls[girlIndex]){
          girlIndex=Math.floor(Math.random()*10);
        }
        girl=game.girls[girlIndex];

        // girl.number=girlIndex;
        girl.box=box;
        box.girl=girl;

        game.activeBoxes[boxIndex]=true;
        game.activeGirls[girlIndex]=true;

        girl.active();





        // setTimeout(function(){game.start()},100+Math.random()*300);
        setTimeout(function(){game.start()},200)
      },

      // 修改得分
      changeScore:function(score){
        var scoreEle=$('.score i'),
            newScore=parseInt(scoreEle.html())+score;
        scoreEle.html(newScore);
      }
    }





  </script>
</body>
</html>